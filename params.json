{"name":"EntityFramework Hooks","tagline":"Provides an extension points for EF DbContext in order to hook database operations.","body":"EntityFramework Hooks\r\n==============\r\n\r\nEntityHooks provides an extension points for EF Code First DbContext in order to hook database operations.\r\nIt is designed to be easy-to-use, unit-testable and IoC compatible.\r\n\r\n## How to use\r\n\r\n### Installation\r\nInstall [NuGet package](https://www.nuget.org/packages/EntityHooks/) from [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console):\r\n```\r\nPM> Install-Package EntityHooks\r\n```\r\n\r\n### Fluent interface\r\nReference *System.Data.Entity.Hooks.Fluent.dll* assembly and include namespace in order to use fluent hooking interface.\r\n```csharp\r\nusing System.Data.Entity.Hooks.Fluent;\r\n```\r\nLogging of loading *Order* entities from datatbase:\r\n```csharp\r\ndbContext.CreateHook()\r\n        .OnLoad<Order>()\r\n        .When(order => order.Status != 0)\r\n        .Do(order => _logger.Write(\"Loaded entity \" + order.Id));\r\n```\r\nSetting date when *Order* entity has been modified:\r\n```csharp\r\ndbContext.CreateHook()\r\n         .OnSave<Order>()\r\n         .When(EntityState.Added | EntityState.Modified)\r\n         .And(order => order.Status == 1)\r\n         .Do(order => order.ModifiedDate = DateTime.UtcNow);\r\n```\r\nDelete *Order* entity if either *CustomerId* or *CategoryId* is *NULL*:\r\n```csharp\r\ndbContext.CreateHook()\r\n         .OnSave<Order>()\r\n         .When(order => order.CustomerId == null || order.CategoryId == null)\r\n         .Do(order => dbContext.Set<Order>().Remove(order));\r\n```\r\nHowever, it is still possible to attach any *IDbHook* implementation through fluent interface:\r\n```csharp\r\ndbContext.OnLoad()\r\n         .Attach(new MyFancyHook())\r\n         .Attach(new CustomHook());\r\ndbContext.OnSave()\r\n         .Attach(new MyFancyHook());\r\n```\r\n\r\n## How hooks are called\r\n\r\n- Load hooks are called in the order they were registered when [*ObjectContext.ObjectMaterialized*](http://msdn.microsoft.com/en-us/library/system.data.objects.objectcontext.objectmaterialized(v=vs.110).aspx) event occur.\r\n- Save hooks are called in the order they were registered for each entry in [*DbChangeTracker*](http://msdn.microsoft.com/en-us/library/system.data.entity.infrastructure.dbchangetracker(v=vs.113).aspx) before actual saving.\r\n\r\nHook is any class, that implements *IDbHook* interface. \r\n```csharp\r\npublic interface IDbHook\r\n{\r\n        void HookEntry(IDbEntityEntry entry);\r\n}\r\n```\r\n*IDbEntityEntry* provides information about entity and it's state ([*EntityState*](http://msdn.microsoft.com/en-us/library/system.data.entitystate(v=vs.110).aspx) enumeration).\r\nAs you may have noticed, *IDbHook* interface don't have neither information about type of entity, which hook should be applied to, nor predicate when to invoke hook. That means, that implementors of *IDbHook* interface should provide their own logic, if needed.\r\n\r\n**NOTE:** Instead of implementing *IDbHook* you may use in-build generic ```DbHook<TEntity>``` class, which provides calls user-specified action for entities of *TEntity* type and specific state.\r\n\r\n### Entity state mutability\r\nEntity state, provided by *IDbEntityEntry* argument passed to *IDbHook.HookEntry* method, reflects current state for Load or Pre-save hooks. If hook modifies state of entity, all further invoked hooks for that entity called with new state. However, for Post-save hooks it reflects the state of entity right before saving changes, despite the fact that actual state in that case might be *Unchanged*.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}